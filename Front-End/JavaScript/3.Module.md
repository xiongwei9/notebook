# Module

从诞生至今很长一段时间以来，JavaScript一直没办法写大型项目的重要原因就是，JavaScript先天缺乏一项功能：模块。没有模块支持的JavaScript几乎所有代码都要写到一个文件中，虽然在浏览器中可以把代码写到多个文件中并通过script标签引入，但是这又会带来很多全局变量。

在ES6出来以前，是CommonJS规范弥补了这种语言缺陷。下面分别看一下CommonJS（主要针对NodeJS的实现）与ES6的模块加载功能。

## 1. CommonJS模块

**1.1 模块引用**

````javascript
// 引用util模块
const util = require('util');
````

**1.2 模块定义**

对于NodeJS，一个文件就是一个模块。在模块中，上下文提供了require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或变量，并且它是唯一的导出出口。在模块中，还存在module对象，它代表模块自身，而exports是module的属性。

````javascript
// demo 1
// 此模块导出add函数
exports.add = (...args) => {
    let sum = 0;
    for (let v of args) {
        sum += v;
    }
    return sum;
};
// 导出name变量、
exports.name = 'xiongwei';
````

````javascript
// demo 2
// 导出对象
module.exports = {
    add: () => {},
    name: 'xiongwei',
};
````

以上两个demo最终导出的结果是一样的。实际上通过require()函数导入一个模块时，函数返回的就是被导入模块的exports对象（也可以是字面量）。那为什么要加上一个module对象呢？按Node的实现，一个模块在编译执行的过程中，它的整个内容会被包装到一个函数中：

````javascript
(function (exports, require, module, __filename, __dirname) {
    // content of module
});
````

在模块中导出变量或方法时，可以直接挂在exports的属性上。但是都知道修改函数的形参对实参无任何影响的，当我们要直接把一个大对象导出来时，`exports={xxx}`是不会有效果的，所以需要使用`module.epxorts`。

**1.3 路径分析和文件定位**

在Node对CommonJS的实现中，通过require()方法导入过的模块，Node会把模块编译和执行之后的对象缓存起来，当相同模块被再次加载时，一律采用缓存中的对象（此对象是公用的，若对象的属性被改，会影响到别的地方）。所以说多次require()同一个模块，模块中的代码只会在第一次被执行。

当模块引入的时候，一般可以通过以下几类模块标识符表示：

1. 核心模块，如http、fs、path等。此类模块加载顺序的优先级仅次于缓存。
2. ..或.开始的相对路径或以/开始的绝对路径文件模块。
3. 自定义模块。一般通过npm下载过来的模块都通过这种方式导入，这种是效率最慢的，它会从当前文件目录到文件系统根目录搜索node_modules，直到在node_module里找到对应模块。

最后是文件定位。require()在分析自定义模块的标识符的过程中，可以出现标识符中不包含文件扩展名的情况，在这种情况下，Node会按.mjs、.js、.json、.node的次序补足扩展名，依次尝试。一般除了.js（或.mjs）其它都应该加上扩展名，可以提升一点点效率。

如果经过搜索上面的扩展名对应的文件都不存在，且得到一个目录，那Node会把此目录当做一个包，从目录里取package.json文件，用其中的main属性指定的文件来作为模块处理。而如果main属性指定的文件名错误，或者压根没有package.json文件，那Node会将index当做默认文件名，依次找index.js、index.json、index.node。

## ES6 Module