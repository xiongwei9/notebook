# 浏览器渲染机制

一直以来对浏览器的加载、解析、渲染过程等充满疑惑，网络上有许多优秀的文章，但比较杂，感觉没有一篇是适合我这么个前端小白的，所以自己写了这篇总结，希望能比较简单全面地梳理一遍整个流程或机制。

## 从用户输入URL开始

当用户输入URL并按下回车键的时候，计算机在底下进行了许多操作，下面比较简略地概括：

1. 解析URL字符串，并进行DNS查询，若计算机的host缓存已存在对应域名与IP地址的映射，则直接向服务器发出连接请求；否则先向DNS服务器查询目标服务器的IP地址
2. 与服务器建立TCP连接，并开始数据通信（一般是使用HTTP协议请求-响应的模式）
3. 一般的页面请求会先得到一个HTML文件（或文件的一个个小片段），浏览器会先根据html头部信息中的charset="xxx"字段知道页面是用什么编码方式的，然后逐个字符地解码并开启浏览器的渲染过程

这就是用户浏览网页的大致流程，本文接下来将重点探究第三点。

## 浏览器渲染流程

1. 拿到html文件后，浏览器就开始自上而下解析、构建DOM树。此过程中，当遇到CSS时，并行加载与解析，生成CSSOM；当遇到图片等资源时，并行下载资源；当遇到JS文件或代码时，则暂停DOM树与CSSOM的构建，等待JS代码或文件的加载、解析与执行，这是因为JS代码可能会修改DOM，在JS执行完毕前，后续所有资源的加载可能是没必要的。
2. 解析完DOM和CSSOM后，浏览器引擎会通过DOM树和CSSOM树来构造渲染树（除去DOM中不可见的link/head等标签，并计算出各个标签元素的大小位置等）。
3. 根据渲染树计算页面图层（像素级），调用操作系统的GUI接口绘制出页面效果。

从上面三步可以看出，HTML必然是第一个加载，其它任何资源都是通过HTML标签获取基本信息、然后向服务器请求的。其中，在加载或解析CSS、JS的过程中，可能会存在一些阻塞行为：

- **CSS: **DOM与CSSOM的解析并不会相互阻塞。CSS文件的加载不影响JS文件的加载，但会阻塞JS的执行，因为JS可能会尝试获取DOM节点的样式属性，所以在JS执行前要保证CSS解析完。

  页面是由DOM与CSSOM共同构造出来的渲染树渲染出来的，这一点会给性能造成严重影响：默认情况下，CSS会阻塞渲染。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK（这主要是为了避免没有 CSS 的 HTML 页面丑陋地“裸奔”在用户眼前）。所以我们必须保证CSSOM能尽快地构建出来，这也是CSS基本都放在HTML头部的原因。

- **JavaScript: **由于JS代码可能会修改DOM，在JS执行完毕前，后续所有资源的加载可能是没必要的。所以一旦遇到JS代码，这段JS代码之后的所有DOM或CSSOM都要等待JS执行完，如果JS代码还没加载，那还需要等它下载完成。除此之外，JS执行时，DOM元素必须是已存在的，否则JavaScript中的DOM操作将无效或报错。

  所以一般我们都会把script标签都放在body标签的最后。有必要的话，可以给script标签加上defer或async属性来使JS文件异步加载，延后执行。

实际上，上述的整个过程，包括JS的执行，都可以在Chrome Performance录制并一窥究竟哦！各个浏览器引擎的这个渲染过程在实现上都是大同小异的，如下是webkit引擎大概的流程图：

![webkit rendering](./assets/webkit-rendering.png)



## 回流与重绘

正如上面的渲染流程所言，浏览器通过把html与css代码描述成DOM和CSSOM，并结合生成渲染树来渲染出各种美妙的页面。所以页面最后展示给用户的样子是由渲染树决定的，而渲染树又是由DOM与CSSOM共同构造的。一旦JavaScript做了DOM操作或修改了某元素的样式，那会发生什么事情呢？

![reflow_repaint](./assets/reflow-repaint.png)

- 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（Reflow，也叫重排）
- 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘（Repaint）

这两个其实都是相当耗性能的，但是从上面的描述可以知道，回流必然导致重绘，反之则不会。所以回流实际产生的损耗要大得多！下面看一下会引起**回流**的DOM操作，也许可以对性能优化有一点帮助：

1. 获取某些属性的值，它们有offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight等。因为这些值都是需要即时计算得到的，浏览器为了计算这些值，会触发回流
2. 改变DOM树结构，比如对DOM元素的增删、移动等。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素
3. 改变DOM元素的几何属性（如width、height、padding、margin、left、top、border等等）。所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算

上面三个DOM操作造成的性能消耗依次增大，一般而言我们遇到这些操作时，可以通过JS变量缓存中间数据、使用css class批量修改样式而非对着DOM元素一个一个改、在操作前把元素display: none最后再把display改回来等方法尽量避免回流太多。

理论上呢，每执行一次上面的“回流性”DOM操作或其它“重绘性”DOM操作，浏览器都应该做一次回流或重绘。但是实际上一些浏览器本身也对类似的操作做一定优化的，比如说Chrome浏览器自己缓存了一个flush队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队！这些（Layout、Painting）同样通过Chrome Performance录制的片段可以看到。

## 参考资料

技术书：

- [前端性能优化原理与实践](https://juejin.im/book/5b936540f265da0a9624b04b/section)

浏览器加载：

- [浏览器~加载，解析，渲染](http://www.jianshu.com/p/e141d1543143)
- [研究首屏时间？你先要知道这几点细节](http://www.alloyteam.com/2016/01/points-about-resource-loading/)
- [从web浏览器的渲染到性能优化](http://blog.csdn.net/allenliu6/article/details/76609929)
- [深度剖析浏览器渲染性能原理，你到底知道多少？](http://www.jianshu.com/p/a32b890c29b1)

回流与重绘：

- [减少页面回流与重绘（Reflow & Repaint）](http://harttle.com/2015/08/11/reflow-repaint.html)
- [重绘，回流和合成，了解基本浏览器绘制帮你优化页面性能](https://zhuanlan.zhihu.com/p/23428399)