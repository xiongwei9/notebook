# 查询优化

## 使用索引

用来加速查询的技术有很多，其中最为重要的就是索引。优化查询的过程，应该首先使用索引来最大程度地改进性能，然后再看看是否还有其它有用的技术。

### 索引的优点

无索引的表就只是一组无序的行，若想从中找到某一行，需要检查表的每一行，看看它是否与那个期望值相匹配，这是一个全表扫描操作，其效率很低。而对表中的某一列创建一个索引，索引是独立于表里的数据行的，那么我们就能只扫描索引（索引是有序的，底层可以使用二分查找法等），就能找到对应的行。

例如，存在3个表，各有1000行数据，如果对它们执行连接查询，那么可能的组合总共有1000\*1000\*1000种，将花费大量时间。如果对3个表的对应列分别创建索引，那么在连接查询时只要从第一张表的索引里一个个读取，并利用其它两表的索引查找对应的值即可。这样的优化，比不使用索引要快100万倍。

MySQL使用索引的方式有如下几种：
- 加快对WHERE子句匹配的行进行搜索的速度，或者用于加快对，与另一个连接表里的行匹配的行，进行搜索的速度。
- 对于使用MIN()或MAX()函数的查询，可以不用逐行检查，快速找到索引列里的最小值或最大值。
- 对于ORDER BY或GROUP BY子句，使用索引即可高效地完成分类和分组操作。
- 有时，MySQL也会通过索引来读取查询所请求的所有信息（所请求的列是索引列）。
- 注意，在查询时，尽量不要对索引列进行计算，否则不会用到索引。也就是说，索引列应该单独在表达式的一侧。


### 索引的代价

1. 索引可以加快检索速度，但是它同时也降低了索引列插入、删除和更新值的速度。也就是说，索引降低了大部分与写入相关的操作的速度，因为写入一个行不仅是写入一个数据行，还要更改索引。表的索引越多，需要做出的更改就越多，平均性能下降得也就越多。对于写操作较多的表而言，索引更新的开销会非常大。
2. 索引也会占用磁盘空间，多个索引会占据更大的空间。与没有索引相比，使用索引会让你很快便达到表的大小极限。

### 索引的挑选

1. 为用于搜索、排序或分组的列创建索引，而对于用作输出显示的列则不用创建索引。也就是说，最佳索引候选列是那些出现在WHERE子句中的列、连接子句中的列，或者出现在ORDER BY或GROUP BY子句中的列。
2. 认真考虑数据列的基数，列的基数（cardinality）是指它所容纳的所有非重复值的个数。相对于表里行的总数来说，列的基数越高（它包含的唯一值多，重复值少），索引的使用效果越好。
3. 索引短小值。应尽量选用较小的数据类型，尤其是主键值。短小值可以加快比较操作、减少对磁盘IO请求、提高缓存命中率。
4. 索引字符串值的前缀。想要对字符串列（CHAR、VARCHAR、BINARY、VARBINARY、TEXT、BLOB）进行索引，应当尽可能指定前缀长度，而不用对整列进行索引，可以节省大量的索引空间以及加快查询。
5. 利用最左前缀。当创建包含n个列的复合索引时，实际上会创建n个专供MySQL使用的索引。复合索引相当于多个索引，而索引中最左边的任意数据列集合都可用于匹配各个行，这样的集合即为“最左前缀”，在查询时可以多利用这种特性。
6. 不要建立过多的索引。过多索引会对写操作造成较多开销，当表有太多索引时，MySQL存在无法使用最好索引的可能。其次，如果已存在最左前缀索引，不应该再添加最左子集合的索引。
7. 让参与比较的索引类型保持匹配。索引类型有B树索引、散列索引等，对于精确匹配的比较操作（如相等）后者更快，而对于精确比较或范围比较，前者也许快点。应该合理判断。
8. 利用慢查询日志找出那些性能低劣的查询。


## MySQL查询优化程序

当调用语句时，MySQL会先对它进行分析，判断出可以使用哪些优化操作来加快处理速度。当然，MySQL的查询优化程序会充分利用索引等信息。如下语句MySQL会执行得飞快：

    SELECT * FROM tbl_name WHERE FALSE;

这个示例里，MySQL会检查WHERE子句，发现并没有符合查询条件的行，因此根本就不会去搜索表。通过执行EXPLAIN语句，可以看到MySQL在执行语句的相关信息或过程显示出来。

    EXPLAIN SELECT * FROM tbl_name WHERE FALSE\G


### 工作原理

查询优化程序有几个目标，主要是：尽可能使用索引，并且使用最严格的索引来消除对行数量随时可能快速增加的顾虑。

### 使用EXPLAIN检查优化程序的操作

EXPLAIN语句提供的信息，有助于我们了解优化程序为处理各种语句而生成的执行计划。此语句的输出结果对索引的描述：
- type的值表明，优化程序可以使用索引来搜索特定范围内的值，而不是ALL。
- possible_keys和key的值表明，优化程序会把对应列上的索引视为候选索引，而实际上也会使用某个索引。
- row的值表明，优化程序估计完成此次查询需要检查多少行数据。

EXPLAIN语句可以让我们了解到：以何种方式编写表达式会更优，验证增加索引能否有助于优化程序更有效地执行某条语句。另外，可以用ANALYZE TABLE table_list;语句来帮助优化程序获得更有价值的估算值。



## 选择利于高效查询的数据类型

1. 多用数字运算，少用字符串运算。不过可以用ENUM或SET类型，它们内部是以数字形式表示的，处理效率更高。
2. 当较小类型够用时，就不要用较大类型。
3. 把数据列声明成NOT NULL。这样处理速度也会更快，因为在查询处理期间，不再需要检查该列的值是否为NULL。
4. 考虑使用ENUM列。
5. 使用PROCEDURE ANALYSE()。如SELECT * FROM tbl_name PROCEDURE ANALYSE();可以得到对适用于表里各个的优化数据类型的建议。
6. 整理表碎片。对于那些频繁修改的表，尤其是那些包含有可变长度数据列的表，往往会产生大量碎片。对于MyISAM或InnoDB表，可定期用OPTIMIZE TABLE。
7. 把数据压缩到BLOB或TEXT列。此办法特别适用于存储那些难以用标准表结构表示的数据，或者那些会随时间变化的数据。比如，让负责处理Web表单的应用程序把答案数据压缩成某种结构的数据（json），然后再把它插到单个的TEXT列里。
8. 使用合成索引。
9. 避免检索很大的BLOB或TEXT值。
10. 把BLOB或TEXT列剥离出来形成一个单独的表。


## 选择利于高效查询的表存储格式


## 高效加载数据

- 把数据从缓存刷新到磁盘的次数越少，数据加载的速度就越快。批量加载的效率比单行加载的效率更高，因为插入的行可以先缓存，然后在加载操作结束时再刷新到磁盘。
- 表的索引越少，加载速度越快。
- 与长SQL语句相比，短语句的数据加载速度更快。这是因为它们在服务器上的解析操作会更少，并且它们可以更加快速地通过网络从客户端发送到服务器。

因此，LOAD DATA（包括各种形式）的效率比INSERT的高，因为它是批量加载行。服务器一次只能解析和解释一条语句，而不会同时处理几条语句。另处，只有在所有行都处理完之后，索引才会需要刷新，而不是在每个行处理完之后，便立即去刷新。


## 调度、锁定和并发

MySQL的调度策略总结如下：
- 写入的优先级比读取的高，写入与读取操作是互斥的。
- 表的写入操作一次只能进行一个，多个写入请求按其到达的先后顺序依次处理。
- 可以同进处理多个对同一个表的读取操作。

存储引擎使用的锁定级别，对客户端之间的并发性有显著的影响。假设有两个客户端，它们各自都想要在给定的表里更新某行，为完成这个更新，每个客户端都会需要一个写入锁定。此时，对于InnoDB表，只要两个客户端不会同时更新同一行，那么两个更新操作就可以同时处理。但对于MyISAM表，锁定的级别是对整个表的。

一般情况下，更精细的锁定会有更好的并发性。但就死锁防止而言，表锁定能比更精细的锁定带来更多的好处。比如，在事务开始的时候，存储引擎还没有获得所有必要的锁定。事实上，在事务处理过程中，只有在必要时才需要获得锁定。因此有可能出现这种情况，即两个查询都获得了锁定，然后它们会试图进一步获得这样的锁定：它们每一个都在期望那些已占用的锁定被解除。结果，每一个客户端都在它能继续下一步操作之前，占据着其它客户端所需要 的锁定。这就会导致死锁，并且只有服务器中止其中一个事务才能解决此问题。